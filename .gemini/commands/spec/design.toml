description = "Generate the technical design for a spec after ensuring requirements are approved."
prompt = """
# Task: Technical Design Generation for '{{args}}'

You are an expert AI system architect. Your goal is to create a comprehensive technical design for the specification **{{args}}** with emphasis on domain modeling and complete data structure identification.

---
### PHASE 1: REQUIREMENTS APPROVAL
---
**Your Goal:** Ensure the requirements for this spec are approved before proceeding.

**Actions:**
1.  **Check State:** Read the metadata file at `docs/specs/{{args}}/spec.json`.
2.  **Verify Approval:** Check if `approvals.requirements.approved` is `true`.
3.  **If Not Approved:**
    a.  Show the user the content of `docs/specs/{{args}}/requirements.md`.
    b.  Ask the user the exact question: "The requirements for '{{args}}' are not yet approved. Please review them. To confirm your approval and proceed, please respond with 'y'."
    c.  **Await user response.** If the user responds with 'y', proceed. Otherwise, stop.
    d.  **Update State on Approval:** If the user approved, use the `replace` tool to update `docs/specs/{{args}}/spec.json`. Find `"approved": false` for requirements and replace it with `"approved": true`. Also, update the phase to "requirements-approved".

---
### PHASE 2: DOMAIN-FOCUSED DESIGN GENERATION
---
**Prerequisite:** Requirements are now approved.

**Actions:**
1.  **Load Context:**
    - Read the approved `docs/specs/{{args}}/requirements.md`.
    - Read all steering documents from `docs/steering/*.md` (`tech.md`, `structure.md`).
2.  **Conduct Domain Analysis (MANDATORY):**
    - **For CLI Tools:** Identify all commands, subcommands, options, arguments, input/output formats, configuration files, error codes.
    - **For Web Applications:** Identify all entities (User, Role, Permission, Settings, Records), relationships, API endpoints, data validation rules, business constraints.
    - **For Libraries/SDKs:** Identify all public interfaces, data types, error types, configuration schemas, callback signatures.
    - **For Data Processing:** Identify input schemas, transformation rules, output formats, intermediate data structures, validation constraints.
3.  **Analyze Codebase (MANDATORY):**
    - Conduct a deep analysis of the existing codebase. Identify reusable patterns, components, and utilities. Document how the new design will integrate with or extend existing code.
4.  **Generate Document:** Create the content for `design.md` using the template from `.gemini/templates/spec/design-template.md`. Ensure every requirement from `requirements.md` is addressed in the design. **CRITICAL:** Include comprehensive domain modeling section with complete type definitions, schemas, and constraints.
5.  **Save Document:** Save the content to `docs/specs/{{args}}/design.md` using the `write_file` tool.
6.  **Auto-validate Design:** Run an internal validation check to ensure the design is architecturally sound, covers all requirements, aligns with steering documents, and includes complete domain modeling. Report any major issues.
7.  **Update State:** Use the `replace` tool to update `docs/specs/{{args}}/spec.json`. Find the line `"phase": "requirements-approved"` and replace it with `"phase": "design-generated"`. Also, update `approvals.design.generated` to `true`.
8.  **Request Approval:** Present the `design.md` to the user and ask for approval with the exact question: "Does the `design.md` look correct with complete domain modeling? To approve it and proceed to task generation, please run `/doc:tasks {{args}}`."
"""