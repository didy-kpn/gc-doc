# Spec-Driven Development 分析レポート

## 概要

Spec-Driven Development（仕様駆動開発）は、従来のソフトウェア開発プロセスを覆すアプローチである。この手法では、仕様書は単なる設計図やドキュメントではなく、コードを直接生成するための**実行可能な成果物**として扱われる。コードが主役であった传统的な開発とは異なり、仕様が開発の中心となり、実装を直接駆動する。これにより、仕様と実装の乖離を防ぎ、高品質なソフトウェアを迅速に構築することを目指す。

## 目的と非目的

### 目的

*   **意図駆動開発**: 「どのように(How)」実装するかよりも先に、「何を(What)」なぜ(Why)」作るのかという意図を明確に定義する。
*   **リッチな仕様作成**: ガイドラインと組織的な原則を用いて、曖昧さのない詳細かつ構造化された仕様を作成する。
*   **多段階の洗em**: プロンプトから一度にコードを生成するのではなく、仕様定義、計画、タスク分割といった複数のステップを経て段階的に洗練させていく。
*   **技術非依存**: 特定のプログラミング言語、フレームワーク、技術スタックに縛られない開発プロセスを確立する。
*   **反復的な機能強化**: 新機能の追加や既存システムの近代化など、初期開発（グリーンフィールド）だけでなく、運用中のプロジェクト（ブラウンフィールド）にも適用する。

### 非目的

*   **ワンショットでのコード生成**: 単一のプロンプトから完璧なアプリケーションを一度に生成すること。
*   **特定技術への固執**: 特定のフレームワークや言語でのみ機能する開発プロセスであること。
*   **仕様書の破棄**: 実装が完了した後に仕様書が陳腐化し、捨てられること。

## 使い方

Spec-Driven Developmentは、`specify` CLIツールとAIコーディングエージェント（Gemini, Claude Codeなど）を組み合わせて実践する。

1.  **プロジェクトの初期化**:
    ```bash
    uvx --from git+https://github.com/github/spec-kit.git specify init <PROJECT_NAME>
    ```
    これにより、開発に必要なテンプレートやスクリプトがプロジェクトに導入される。

2.  **仕様の作成 (`/specify`)**:
    AIエージェントのチャットで `/specify` コマンドを使い、構築したいアプリケーションの**WHAT（何）**と**WHY（なぜ）**を自然言語で記述する。この段階では技術的な詳細は含めない。
    ```
    /specify 写真をアルバムに整理するアプリを構築してください。アルバムは日付でグループ化され、ドラッグ＆ドロップで並べ替え可能です...
    ```

3.  **技術計画の作成 (`/plan`)**:
    `/plan` コマンドを使い、使用する技術スタックやアーキテクチャの選択肢を指示する。
    ```
    /plan このアプリケーションはViteを使い、ライブラリは最小限にします。HTML, CSS, JavaScriptを基本とし、メタデータはローカルのSQLiteに保存します...
    ```

4.  **タスクへの分割と実装 (`/tasks`)**:
    `/tasks` コマンドで実行可能なタスクリストを生成し、AIエージェントに各タスクの実装を指示する。

## 詳細なフロー

Spec-Driven Developmentは、主に3つのコマンド (`/specify`, `/plan`, `/tasks`) によって駆動され、それぞれが明確なフェーズに対応している。

### フェーズ1: 仕様定義 (`/specify`)

*   **定義**: ユーザーの要求（WHAT/WHY）を構造化された仕様書 (`spec.md`) に落とし込むフェーズ。
*   **進めて良い条件**: 開発したい機能のアイデアがある。
*   **出口基準**:
    *   `spec.md` ファイルが生成されている。
    *   仕様書内の `[NEEDS CLARIFICATION]` （要明確化）項目がすべて解決されている。
    *   要求がテスト可能かつ曖昧さなく記述されている。
    *   実装詳細（言語、フレームワークなど）が含まれていない。
*   **戻る条件**: レビューの結果、要求に曖昧さや矛盾が見つかった場合。
*   **レビュー観点**:
    *   実装詳細が含まれていないか？
    *   ユーザー価値とビジネスニーズに焦点を当てているか？
    *   非技術者でも理解できる言葉で書かれているか？
    *   要求はテスト可能で、成功基準は測定可能か？

### フェーズ2: 計画 (`/plan`)

*   **定義**: `spec.md` をインプットとし、技術スタックの決定、アーキテクチャ設計、各種設計ドキュメントの生成を行うフェーズ。
*   **進めて良い条件**: フェーズ1が完了し、レビュー済みの `spec.md` が存在する。
*   **出口基準**:
    *   `plan.md` ファイルが生成されている。
    *   `research.md`, `data-model.md`, `contracts/`, `quickstart.md` などの設計成果物が生成されている。
    *   プロジェクトの憲法 (`constitution.md`) に照らしたチェック (`Constitution Check`) をパスしている。
    *   技術的な不明点がすべて解決されている。
*   **戻る条件**:
    *   `Constitution Check` に違反し、その正当性が説明できない場合。
    *   設計後に新たな `Constitution Check` 違反が見つかった場合、設計をリファクタリングするためにこのフェーズに戻る。
*   **レビュー観点** (`Constitution Check`):
    *   **シンプルさ**: プロジェクト数は多すぎないか？ 不要なラッパーやデザインパターンを導入していないか？
    *   **アーキテクチャ**: すべての機能はライブラリとして実装されているか？
    *   **テスト (最重要)**: TDD (Red-Green-Refactor) が強制されているか？ テストが実装より先にコミットされるか？ モックではなく実際の依存関係を使用しているか？
    *   **可観測性**: 構造化ロギングが含まれているか？
    *   **バージョニング**: セマンティックバージョニングが計画されているか？

### フェーズ3: タスク分割 (`/tasks`)

*   **定義**: `plan.md` とその他の設計ドキュメントを基に、AIエージェントが実行可能な具体的なタスクリスト (`tasks.md`) を生成するフェーズ。
*   **進めて良い条件**: フェーズ2が完了し、すべての設計ドキュメントが生成されている。
*   **出口基準**:
    *   `tasks.md` ファイルが生成されている。
    *   すべてのタスクが番号付けされ、依存関係が明確になっている。
    *   並列実行可能なタスクには `[P]` マークが付与されている。
    *   TDDの原則に従い、テスト作成タスクが実装タスクより先に来ている。
*   **戻る条件**: 生成されたタスクに漏れや依存関係の間違いがある場合。
*   **レビュー観点**:
    *   すべてのコントラクトに対応するテストタスクが存在するか？
    *   すべてのエンティティに対応するモデル作成タスクが存在するか？
    *   テストタスクが実装タスクより先に配置されているか？
    *   並列実行タスクは本当に独立しているか？

### フェーズ4: 実装と検証

*   **定義**: `tasks.md` に従ってAIエージェントがコードを実装し、テストを実行して検証するフェーズ。
*   **進めて良い条件**: フェーズ3が完了し、実行可能な `tasks.md` が存在する。
*   **出口基準**:
    *   すべてのタスクが完了している。
    *   すべてのテストがパスする。
    *   `quickstart.md` に記載されたシナリオを手動で実行し、動作を確認する。
*   **戻る条件**: ビルドエラーやテスト失敗が発生した場合、関連するタスクに戻って修正する。

## 生成されるドキュメント

| ドキュメント名 | 役割 | 詳細 |
| :--- | :--- | :--- |
| `spec.md` | **機能仕様書** | ユーザー要求（WHAT/WHY）を定義する。ユーザーシナリオ、受け入れ基準、機能要件、主要エンティティなどを記述。技術的な詳細を含まない。 |
| `plan.md` | **実装計画書** | `spec.md` を技術的にどう実現するかを定義する。技術スタック、アーキテクチャ、プロジェクト構造、各フェーズの計画、憲法チェックの結果などを記述。 |
| `research.md` | **技術調査レポート** | `plan.md` 作成時に発生した技術的な不明点（ライブラリの選定、ベストプラクティスなど）を調査し、その決定と根拠を記録する。 |
| `data-model.md` | **データモデル定義** | 機能に必要なエンティティ、その属性、リレーションシップを定義する。 |
| `contracts/` | **APIコントラクト** | APIのエンドポイント、リクエスト/レスポンスのスキーマなどをOpenAPIやGraphQL形式で定義する。 |
| `quickstart.md` | **クイックスタートガイド** | ユーザーシナリオに基づいたテストシナリオや、アプリケーションの基本的な使い方を記述する。E2Eテストのインプットとなる。 |
| `tasks.md` | **タスクリスト** | 実装計画を具体的なコーディングタスクに分解したもの。AIエージェントが一つずつ実行できる粒度で記述される。 |
| `GEMINI.md` 等 | **AIエージェント向けコンテキスト** | プロジェクトで利用中の技術スタックやプロジェクト構造、最近の変更点などを簡潔にまとめたファイル。AIエージェントが効率的に作業するためのコンテキストを提供する。 |

## メリット・デメリット

### メリット

*   **品質の向上**: 仕様と実装が常に同期するため、要求からの逸脱が起こりにくい。
*   **開発速度の向上**: AIエージェントが定型的なコーディングタスクを自動化するため、開発者はより創造的な作業に集中できる。
*   **保守性の向上**: 構造化されたドキュメントが自動生成されるため、プロジェクトへの新規参画者が理解しやすい。
*   **技術的な柔軟性**: プロセス自体は技術に依存しないため、様々なスタックに応用可能。
*   **並行検討**: 複数のアーキテクチャや技術選択肢を並行して試し、最適なものを選択できる。

### デメリット

*   **学習コスト**: 従来の開発フローと大きく異なるため、プロセスに慣れるまでに学習コストがかかる。
*   **プロセスの厳格さ**: 厳格なフェーズとルールが、小規模な修正や探索的な開発においてオーバーヘッドになる可能性がある。
*   **AIエージェントへの依存**: プロセスの大部分がAIエージェントの能力に依存するため、エージェントの性能や制約に大きく影響される。
*   **ドキュメントのオーバーhead**: 多くのドキュメントが生成されるため、それらを管理・レビューする手間がかかる。

## カスタマイズのヒント

この開発フローは、プロジェクトのニーズに合わせてカスタマイズ可能である。

*   **憲法の変更**: プロジェクトルートの `memory/constitution.md` を編集することで、プロジェクト独自の開発原則やコーディング規約を定義し、`/plan` フェーズのレビュー観点に反映させることができる。
*   **テンプレートの変更**: `templates/` 配下の各種テンプレートファイル (`spec-template.md`, `plan-template.md`など) を変更することで、生成されるドキュメントの構造や内容をカスタマイズできる。
*   **スクリプトの拡張**: `scripts/` 配下のシェルスク립トを修正・拡張することで、ブランチ作成ルールやファイル生成のロジックなど、ワークフロー自体を自動化・変更できる。

## 他の駆動開発との関連性

*   **テスト駆動開発 (TDD)**: Spec-Driven DevelopmentはTDDの原則を包含し、さらに強制する。`/plan` フェーズの憲法チェックでは「Red-Green-Refactor」サイクルが必須項目であり、`/tasks` フェーズではテストタスクが実装タスクより先に生成される。TDDが「テスト」から始めるのに対し、Spec-Drivenはさらに上流の「仕様」から始める点が異なる。
*   **ビヘイビア駆動開発 (BDD)**: `spec.md` で `Given/When/Then` 形式のユーザーシナリオを記述する点は、BDDのプラクティスを取り入れている。BDDが人間とコンピュータの間の協力を促進する共通言語を目指すのに対し、Spec-DrivenはAIエージェントが直接解釈し実行可能な、より構造化された仕様を目指す点で一歩進んでいる。
*   **ドメイン駆動設計 (DDD)**: `spec.md` での「Key Entities」の特定や、`plan.md` からの `data-model.md` の生成は、ドメインの概念をコードに反映させるDDDの考え方と高い親和性を持つ。Spec-Drivenは、DDDにおけるドメインモデルを仕様として明確に定義し、そこから実装を駆動する具体的なプロセスを提供する。
