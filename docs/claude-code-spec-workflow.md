# Claude Code Spec Workflow 駆動開発 分析レポート

## 1. 概要

`Claude Code Spec Workflow` は、AI（特にClaude Code）を活用したソフトウェア開発の生産性と品質を向上させることを目的とした、体系的な駆動開発ワークフローです。このワークフローは、新機能開発とバグ修正の2つの主要なプロセスを定義し、それぞれを明確なフェーズに分割します。

各フェーズでは、ドキュメント生成、AIエージェントによる検証、ユーザーによる承認というステップを踏むことで、手戻りを減らし、一貫性のある高品質なコードベースを維持します。特に、`Steering Documents`（指針書）というプロジェクト全体のコンテキストを定義する仕組みにより、AIが生成するコードやドキュメントがプロジェクトの標準に準拠することを保証します。

このシステムは、開発プロセスを自動化し、人間はより創造的な意思決定に集中できるように設計されています。

## 2. 目的と非目的

### 目的

*   **開発プロセスの構造化**: 新機能開発を「要求定義 → 設計 → タスク分割 → 実装」という一貫したフローに沿って進める。
*   **品質の担保**: 各フェーズの生成物（ドキュメント）を専門のAIエージェントが検証し、品質基準を満たしていることを保証する。
*   **一貫性の維持**: `Steering Documents`（`product.md`, `tech.md`, `structure.md`）で定義されたプロジェクト方針（製品ビジョン、技術スタック、命名規則など）に準拠した開発を徹底する。
*   **AIとの協業最適化**: タスクをAIエージェントが実行可能な「アトミック（単一目的）」な単位に分割することで、AIによるコード生成の精度と効率を最大化する。
*   **トレーサビリティの確保**: 要求から実装まで、すべての成果物がドキュメントとして記録され、変更の追跡や影響範囲の特定が容易になる。

### 非目的

*   **小規模な修正の代替**: ドキュメント作成のオーバーヘッドがあるため、ドキュメント不要なほどの軽微な修正には不向きです（ただし、そのための軽量なバグ修正フローが用意されています）。
*   **完全な自動化**: 各フェーズの終わりにユーザーの明確な承認を必要とし、人間の意思決定を尊重します。AIが自律的に全工程を完了するものではありません。
*   **プロジェクト管理ツール**: タスクの進捗管理やチームのコミュニケーションを主目的とするツールではなく、あくまで開発ワークフローを規定し、実行を支援するものです。

## 3. 使い方

このワークフローの利用は、簡単なセットアップといくつかのコマンド実行で開始できます。

1.  **インストール**:
    ```bash
    npm i -g @pimzino/claude-code-spec-workflow
    ```
2.  **プロジェクトへのセットアップ**:
    ```bash
    # プロジェクトのルートディレクトリで実行
    claude-code-spec-workflow
    ```
    これにより、`.claude`ディレクトリと関連ファイルがプロジェクト内に生成されます。

3.  **ワークフローの開始**:
    *   **新機能開発**:
        ```bash
        # Claude Codeのインターフェースで実行
        /spec-create <機能名> "<機能の説明>"
        ```
    *   **バグ修正**:
        ```bash
        # Claude Codeのインターフェースで実行
        /bug-create <バグ名> "<バグの説明>"
        ```

## 4. 詳細なフロー

この駆動開発は、大きく「Spec Workflow（新機能開発）」と「Bug Fix Workflow（バグ修正）」の2つに分かれます。

### 4.1. Spec Workflow（新機能開発）

新機能は、`要求定義` → `設計` → `タスク分割` → `実装` の4つの主要フェーズを経て開発されます。

| フェーズ | コマンド | 生成物 | 役割 |
| :--- | :--- | :--- | :--- |
| **1. 要求定義** | `/spec-create` | `requirements.md` | 機能の目的、ユーザーーストーリー、受け入れ基準を定義する。 |
| **2. 設計** | (要求承認後) | `design.md` | 技術的なアーキテクチャ、コンポーネント、データモデルを設計する。 |
| **3. タスク分割** | (設計承認後) | `tasks.md` | 設計をAIが実行可能なアトミックな実装タスクに分割する。 |
| **4. 実装** | `/spec-execute` | ソースコード、テストコード | タスクを1つずつ実行し、機能を実装する。 |

---

#### **フェーズ1: 要求定義 (Requirements)**

*   **定義**: 機能の目的、ユーザーにとっての価値、具体的な振る舞いを「ユーザーーストーリー」と「受け入れ基準」の形式で定義します。
*   **出口基準**:
    1.  `requirements-template.md` に基づいた `requirements.md` が生成される。
    2.  `spec-requirements-validator` エージェントによる検証をパスする。
    3.  ユーザーが内容を承認する。
*   **進めて良い条件**: ユーザーが「yes」「approved」などで明確に承認した場合。
*   **戻る条件**: 検証で不備が指摘された場合、またはユーザーが修正を指示した場合。
*   **レビュー観点 (`spec-requirements-validator`):**
    *   テンプレート構造への準拠。
    *   ユーザーーストーリーの品質（役割、機能、利益が明確か）。
    *   受け入れ基準の品質（具体的、測定可能、テスト可能か）。
    *   `product.md` との整合性。

---

#### **フェーズ2: 設計 (Design)**

*   **定義**: 要求定義を満たすための技術的な解決策を設計します。アーキテクチャ、コンポーネント間の関係、データモデル、API仕様などを定義します。
*   **出口基準**:
    1.  `design-template.md` に基づいた `design.md` が生成される。
    2.  `spec-design-validator` エージェントによる検証をパスする。
    3.  ユーザーが内容を承認する。
*   **進めて良い条件**: ユーザーが明確に承認した場合。
*   **戻る条件**: 検証で不備が指摘された場合、またはユーザーが修正を指示した場合。
*   **レビュー観点 (`spec-design-validator`):**
    *   `requirements.md` の全要件をカバーしているか。
    *   `tech.md`（技術標準）および `structure.md`（構成規則）との整合性。
    *   既存コードの再利用が考慮されているか。
    *   技術的な実現可能性と品質（セキュリティ、パフォーマンスなど）。

---

#### **フェーズ3: タスク分割 (Tasks)**

*   **定義**: 設計ドキュメントを元に、AIエージェントが実装可能なレベルの具体的でアトミックなコーディングタスクに分割します。
*   **出口基準**:
    1.  `tasks-template.md` に基づいた `tasks.md` が生成される。
    2.  `spec-task-validator` エージェントによる検証をパスする。
    3.  ユーザーが内容を承認する。
*   **進めて良い条件**: ユーザーが明確に承認した場合。
*   **戻る条件**: 検証で不備が指摘された場合、またはユーザーが修正を指示した場合。
*   **レビュー観点 (`spec-task-validator`):**
    *   **アトミック性**: 各タスクが単一目的で、1〜3個の関連ファイルのみを変更し、短時間で完了可能か。
    *   **具体性**: 変更対象のファイルパスが明記されているか。
    *   **トレーサビリティ**: 各タスクがどの要求 (`requirements.md`) と設計 (`design.md`) に対応するかが明記されているか。

---

#### **フェーズ4: 実装 (Implementation)**

*   **定義**: `/spec-execute` または自動生成されたタスクコマンドを使い、`tasks.md` に記述されたタスクを1つずつ実行してコーディングを行います。
*   **出口基準**: `tasks.md` に記載された全てのタスクが完了する。
*   **進めて良い条件**: ユーザーが次のタスクの実行を指示した場合。
*   **戻る条件**: 実装したコードが期待通りに動作しない、またはテストで問題が発覚した場合。この場合、新たなバグ修正フローを開始するか、タスクの再定義が必要になることがあります。
*   **レビュー観点 (`spec-task-executor` & User):**
    *   `spec-task-executor` は、`Steering Documents` と仕様書コンテキストに基づき、規約に準拠したコードを生成します。
    *   最終的なレビューはユーザーが行います。

### 4.2. Bug Fix Workflow（バグ修正）

Spec Workflowよりも軽量な、バグ修正に特化したフローです。

| フェーズ | コマンド | 生成物 | 役割 |
| :--- | :--- | :--- | :--- |
| **1. 報告** | `/bug-create` | `report.md` | バグの現象、再現手順、影響範囲を文書化する。 |
| **2. 分析** | `/bug-analyze` | `analysis.md` |根本原因を調査し、修正方針を計画する。 |
| **3. 修正** | `/bug-fix` | ソースコード | 計画に基づき、コードを修正する。 |
| **4. 検証** | `/bug-verify` | `verification.md` | 修正が有効であること、およびデグレードが発生していないことを確認する。 |

各フェーズはSpec Workflowと同様に、ユーザーの承認を経て次に進みます。

## 5. 生成されるドキュメント

このワークフローでは、開発プロセスを通じて以下のようなドキュメントが生成・活用されます。

### 5.1. Steering Documents (指針書)

プロジェクト全体の永続的なコンテキストを提供し、AIの判断基準となります。`/spec-steering-setup` コマンドで生成されます。

*   **`product.md`**:
    *   **役割**: プロダクトの目的、ターゲットユーザー、主要機能などを定義します。
    *   **詳細**: 「何を」作るべきかの指針となり、要求定義フェーズで特に重要視されます。
*   **`tech.md`**:
    *   **役割**: 技術スタック、アーキテクチャ、利用するライブラリ、技術的な制約などを定義します。
    *   **詳細**: 「どのように」作るべきかの技術的な標準を示し、設計フェーズの基盤となります。
*   **`structure.md`**:
    *   **役割**: ディレクトリ構成、命名規則、インポートパターンなど、コードの構造に関する規約を定義します。
    *   **詳細**: 「どこに」コードを配置し、「どのように」名前を付けるかの規約を定め、コードベースの一貫性を保ちます。

### 5.2. Spec Workflow Documents

新機能開発の各フェーズで生成されるドキュメントです。

*   **`requirements.md`**:
    *   **役割**: 機能要求を定義するドキュメント。
    *   **詳細**: ユーザーーストーリーと受け入れ基準の形式で、機能の振る舞いを具体的に記述します。
*   **`design.md`**:
    *   **役割**: 技術設計を定義するドキュメント。
    *   **詳細**: アーキテクチャ図（Mermaid）、コンポーネントのインターフェース、データモデル、エラーハンドリング方針などを記述します。
*   **`tasks.md`**:
    *   **役割**: 実装計画を定義するドキュメント。
    *   **詳細**: 設計を元に、AIが実行可能なアトミックなタスクリストをチェックボックス形式で記述します。各タスクには対象ファイル、要求参照が含まれます。

### 5.3. Bug Fix Workflow Documents

バグ修正プロセスで生成されるドキュメントです。

*   **`report.md`**: バグの現象、再現手順、影響度などを記録します。
*   **`analysis.md`**: 根本原因の分析結果と、具体的な修正計画を記録します。
*   **`verification.md`**: 修正後のテスト結果、デグレードの有無などを記録し、修正が完了したことを証明します。

## 6. メリット・デメリット

### メリット

*   **高い一貫性と品質**: Steering Documentsと検証エージェントにより、誰が（またはどのAIが）開発しても、プロジェクト標準に準拠した高品質な成果物が得られます。
*   **優れたトレーサビリティ**: 要求から実装までの全プロセスがドキュメント化されるため、仕様変更の影響範囲の特定や、過去の意思決定の確認が容易です。
*   **AI開発の効率化**: タスクをAIが得意な粒度にまで分割することで、AIによるコード生成の成功率を高め、手戻りを削減します。
*   **明確なレビュープロセス**: 各フェーズの終わりに明確な承認ゲートを設けることで、関係者の合意形成を促し、後のフェーズでの大規模な手戻りを防ぎます。
*   **コンテキスト管理の最適化**: `get-*-context` コマンドにより、AIへのコンテキスト提供が効率化され、トークン消費量を削減し、実行速度を向上させます。

### デメリット

*   **オーバーヘッド**: 全ての変更に対してドキュメントを作成するため、非常に小規模な修正にはプロセスが過剰に感じられる場合があります。
*   **厳格なプロセス**: 定義されたフローに従う必要があるため、柔軟性やスピードを最優先する探索的な開発スタイルには不向きな場合があります。
*   **初期設定コスト**: ワークフローを最大限に活用するには、最初にSteering Documentsを適切に定義する必要があります。
*   **AIへの依存**: ワークフローの効率は、AIエージェント（検証、実行）の性能に大きく依存します。

## 7. カスタマイズのヒント

このワークフローは、プロジェクトのニーズに合わせてカスタマイズ可能です。

*   **テンプレートの変更**: `.claude/templates/` 配下のテンプレートファイル（`requirements-template.md`など）を編集することで、生成されるドキュメントの構造や項目を自由に変更できます。
*   **検証ロジックの変更**: `.claude/agents/` 配下のAIエージェントのプロンプトを修正することで、各フェーズでの検証基準（レビュー観点）をプロジェクト独自のものに調整できます。
*   **プロジェクト標準の定義**: **最も重要**なカスタマイズは、`.claude/steering/` 配下の `product.md`, `tech.md`, `structure.md` を充実させることです。これにより、AIが生成する成果物の質と一貫性が飛躍的に向上します。
*   **コマンドの拡張**: `.claude/commands/` 配下の `*.toml` ファイルやマークダウンを編集することで、既存のコマンドの振る舞いを変更したり、新しいコマンドを追加したりすることも可能です（上級者向け）。

## 8. 他の駆動開発との関連性

*   **仕様駆動開発 (SDD - Specification-Driven Development)**: このワークフローはSDDの典型的な実装例です。実装に先立ち、詳細な仕様（要求、設計、タスク）を作成し、その仕様に基づいて開発を進めます。
*   **ビヘイビア駆動開発 (BDD - Behavior-Driven Development)**: `requirements.md` における「ユーザーーストーリー」と「受け入れ基準」の形式は、BDDの思想に強く影響を受けています。このワークフローは、BDDで定義された振る舞いをAIが実装するための具体的なプロセスを提供します。
*   **テスト駆動開発 (TDD - Test-Driven Development)**: 設計フェーズで「Testing Strategy」を定義し、タスク分割フェーズでテスト作成をタスクとして含めることを推奨しており、TDDの原則を取り入れています。ただし、TDDの厳密な「Red-Green-Refactor」サイクルを強制するものではありません。
*   **ドメイン駆動設計 (DDD - Domain-Driven Design)**: `product.md` は、DDDにおけるユビキタス言語やドメインの知識を軽量に表現する試みと捉えることができます。プロジェクトの核となるビジネスロジックや目的をAIと共有するための重要な手段です。
